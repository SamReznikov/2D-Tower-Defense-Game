/**
 * MainGame.java by Sam Reznikov
 * January 19, 2019
 * Main class of the Obstruction tower defense game. Stores main instance variables and keeps the world up to date

 * FUNCTIONALITY/FEATURES AVAILABLE
 * Varying types of enemies spawn regularly on the left side of the path and automatically make their way towards the castle 
 * When an enemy reaches the castle, the player loses some health
 * The player can place 3 different kinds of towers on unobstructed tiles to prevent enemies from reaching the castle
        *The Gun Tower: Fires projectiles towards a nearby enemy at regular intervals
        * The Coin Tower: Generates money slowly over time
        * The Magic Tower: Enemies within its radius take constant damage and are set aflame
 * The player can upgrade each tower up to two times, each time improving its look and corresponding stats
 * The player can sell a tower and earn money for it
 * The player can pause and fast-forward the game
 * The game is won by killing a certain amount of enemies, and is lost if the player loses all his health
 * The player has two powerful abilities which he can use for a costly fee
        * Heal ability: the player resets his health back to normal
        * Skull ability: kills all enemies onscreen
 */

//IMPORT NECESSARY JAVA LIBRARIES
import java.util.Scanner;
import java.util.ArrayList;
import java.util.concurrent.TimeUnit;

import javax.sound.sampled.DataLine;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.AudioInputStream;
import javax.sound.sampled.Clip;
import javax.sound.sampled.UnsupportedAudioFileException;

import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.Graphics;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Toolkit;
import java.awt.image.BufferedImage;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.event.MouseEvent;

import javax.swing.JFrame;
import javax.swing.JPanel;

import javax.imageio.ImageIO;

import java.io.File;
import java.io.IOException;

public class MainGame extends JPanel implements MouseListener, MouseMotionListener {
  //CREATE NECESSARY INSTANCE VARIABLES
  static final long serialVersionUID = 0;
  
  //Position and Dimension-related values
  static final int WINDOW_LENGTH = 1000; //hypothetical window length for buttons
  static final int WINDOW_HEIGHT = 690; //hypothetical window height for buttons  
  static final int STATS_LENGTH = 225; //length of stat display window
  static final int STATS_HEIGHT = 70; //height of stat display window
  static final int STATS_XPOS = WINDOW_LENGTH - STATS_LENGTH-50; //x position fo stat display windo
  static final int ICON_YPOS = 15; //y position for all buttons
  static final int MAP_YSTART = 100; //starting y position of the tilemap
  static final int ICON_SIZE = 50; //button size
  static int towerSize; //tower size
  static final int ENEMY_HEALTH_BAR_LENGTH = 20; //length of enemy health bars
  static final int ENEMY_HEALTH_BAR_HEIGHT = 5; //height of enemy health bars
  
  //Game Stat-related values
  static double enemyFreq = 50; //enemy spawn frequency
  static int enemyFreqCount = 0; //enemy spawn count
  static double enemyMinHealth = 150; //enemy minimum health
  static double enemyMaxHealth = 200; //enemy maximum health
  static double enemyMinSpeed = 0.7; //enemy minimum speed
  static double enemyMaxSpeed = 0.9; //enemy maximum speed
  
  static final int PLAYER_HEALTH = 100; //player's default health
  static final int PLAYER_MONEY = 50; //player's default money
  static final int ENEMY_GOAL = 50; //the goal of #  of enemies to kill
  
  static final double COIN_AMOUNT = 2; //default amount of money generated by coin towers
  static final int GUN_DAMAGE = 15; //default gun tower damage
  static final int MAG_DAMAGE = 2; //default magic tower damage
  
  static double gunRange; //default gun tower range
  static double magRadius; //default magic tower radius
  
  static final int GUN_TOWER_COST = 20; //default gun tower cost
  static final int COIN_TOWER_COST = 30; //default coin tower cost
  static final int MAG_TOWER_COST = 40; //default magic tower cost
  
  static final int GUN_TOWER_FREQ = 150; //default gun tower frequency
  static final int COIN_TOWER_FREQ = 50; //default coin tower frequency
  static final int MAG_TOWER_FREQ = 1000; //default magic tower frequency (basically constant)
  
  //Other values
  static final int COIN_SPIN_FREQ = 50;  //default coin sprite spin frequency (used for updating sprite)
  static final int FIRE_BURN_FREQ = 50; //default fire sprite burn frequency (used for updating sprite) 
  static final int GAME_LOOP_DELAY = 20; //default delay for game loop
  static int gameLoopDelay = GAME_LOOP_DELAY; //current delay for game loop
  static int fastForwardSpeed = 17; //fast forward speed
  static Clip fireClip = null;
  static boolean started = false;
  static boolean gameOver = false;
  static int screenHeight; //screen height
  static int screenWidth; //screen width
  
  //Images
  static BufferedImage stone; //stone path image
  static BufferedImage stone2; //2nd stone path image
  static BufferedImage stone3; //3rd stone path image
  static BufferedImage grass; //grass tile image
  static BufferedImage grass2; //2nd grass tile image
  static BufferedImage grass3;  //3rd grass tile image
  static BufferedImage rock; //obstacle image
  static BufferedImage rock2; //2nd obstacle image
  
  static ArrayList<BufferedImage> paths = new ArrayList<BufferedImage>(); //list of path tiles
  static ArrayList<BufferedImage> obstacles = new ArrayList<BufferedImage>(); //list of obstacle tiles
  static ArrayList<BufferedImage> normalTiles = new ArrayList<BufferedImage>(); //list of grass tiles
  
  static BufferedImage topBar; //top bar of gui image
  static BufferedImage hammer; //hammer icon image
  static BufferedImage fastforward; //fast forward icon image
  static BufferedImage pause;//pause icon image
  static BufferedImage coin;//coin icon image
  static BufferedImage skull;//skull icon image
  static BufferedImage heal; //heal icon image
  static BufferedImage base; //castle icon image
  
  static BufferedImage coins; //coin spritesheet
  static BufferedImage skeletons; //skeleton spritesheet
  static BufferedImage mages; //mage spritesheet
  static BufferedImage baldricks; //baldrick spritesheet
  static BufferedImage fires; //fire spritesheet
  
  static ArrayList<BufferedImage> allFires = new ArrayList<BufferedImage>(); //list of all fire sprites
  static ArrayList<BufferedImage> allCoins = new ArrayList<BufferedImage>(); //list of all coin sprites  
  static ArrayList<ArrayList<BufferedImage>> allSkeletons = new ArrayList<ArrayList<BufferedImage>>(); //sprite list
  static ArrayList<ArrayList<BufferedImage>> allMages = new ArrayList<ArrayList<BufferedImage>>(); //sprite list
  static ArrayList<ArrayList<BufferedImage>> allBaldricks = new ArrayList<ArrayList<BufferedImage>>(); //sprite list
  
  static ArrayList<BufferedImage> skeletonsUp = new ArrayList<BufferedImage>(); //list of up-skeleton sprites
  static ArrayList<BufferedImage> skeletonsLeft = new ArrayList<BufferedImage>(); //list of left-skeleton sprites
  static ArrayList<BufferedImage> skeletonsDown = new ArrayList<BufferedImage>(); //list of down-skeleton sprites
  static ArrayList<BufferedImage> skeletonsRight = new ArrayList<BufferedImage>(); //list of right-skeleton sprites
  
  static ArrayList<BufferedImage> magesUp = new ArrayList<BufferedImage>(); //list of up-mage sprites
  static ArrayList<BufferedImage> magesLeft = new ArrayList<BufferedImage>(); //list of left-mage sprites
  static ArrayList<BufferedImage> magesDown = new ArrayList<BufferedImage>(); //list of down-mage sprites
  static ArrayList<BufferedImage> magesRight = new ArrayList<BufferedImage>(); //list of right-mage sprites
  
  static ArrayList<BufferedImage> baldricksUp = new ArrayList<BufferedImage>(); //list of up-baldrick sprites
  static ArrayList<BufferedImage> baldricksLeft = new ArrayList<BufferedImage>(); //list of left-baldrick sprites
  static ArrayList<BufferedImage> baldricksDown = new ArrayList<BufferedImage>(); //list of down-baldrick sprites
  static ArrayList<BufferedImage> baldricksRight = new ArrayList<BufferedImage>(); //list of right-baldrick sprites
  
  static BufferedImage gunTower1; //gun tower stage 1 image
  static BufferedImage gunTower2; //gun tower stage 2 image
  static BufferedImage gunTower3; //gun tower stage 3 image
  
  static BufferedImage coinTower1; //coin tower stage 1 image
  static BufferedImage coinTower2; //coin tower stage 2 image
  static BufferedImage coinTower3; //coin tower stage 3 image
  
  static BufferedImage magTower1; //magic tower stage 1 image
  static BufferedImage magTower2; //magic tower stage 2 image
  static BufferedImage magTower3; //magic tower stage 3 image
  
  static ArrayList<BufferedImage> gunTowers = new ArrayList<BufferedImage>(); //list of gun tower images
  static ArrayList<BufferedImage> coinTowers = new ArrayList<BufferedImage>(); //list of coin tower images
  static ArrayList<BufferedImage> magTowers = new ArrayList<BufferedImage>(); //list of magic tower images
  
  static BufferedImage rockProjectile; //rock projectile image
  static BufferedImage background; //dark blue background image
  
  //Buttons (IconRecs)
  static ArrayList<IconRec> towerIconRecs; //list of tower buttons
  static ArrayList<IconRec> allIconRecs = new ArrayList<IconRec>(); //list of all buttons
  
  static IconRec skullIcon; //skull button
  static IconRec healIcon; //heal button
  static IconRec upgradeIcon; //upgrade button
  static IconRec sellIcon; //sell button
  static IconRec fastForwardIcon; //fast forward button
  static IconRec pauseIcon; //pause button
  static IconRec coinIcon; //coin button
  
  //Main game objects
  static Player player;
  ArrayList<Enemy> enemies = new ArrayList<Enemy>();
  static ArrayList<ArrayList<Tile>> map = new ArrayList<ArrayList<Tile>>();
  
  //Sound-related
  static ArrayList<Clip> currSounds = new ArrayList<Clip>();
  static String[] soundNames = {"soundtrack", "fireSound", "castlehit", "explosion", "gunshot", "coinSound", "heal", 
    "upgrade", "cash"};
  static int numSounds = 0;
  
// end of instance variables-----------------------------------------------------------------------------------------------------------

  /**
   * paintComponent()
   * This method draws everything on the screen
   * @param Graphics used to draw
   */
  public void paintComponent(Graphics g) {
    //initialize necessary values
    super.paintComponent(g); //call parent constructor   
    Graphics2D graphics2D = (Graphics2D) g; //create new instance of graphics2D
    ArrayList<Projectile> projectilesToDraw = new ArrayList<Projectile>();  //create list of projectiles to draw onscreen
    ArrayList<int[]> circlesToDraw = new ArrayList<int[]>(); //create list of circles for magic towers to draw onscreen
   
    //DRAW TOP BAR MENU
    g.drawImage(topBar, 0, 0, null);
    g.drawImage(topBar, 650, 0, null);
    g.drawImage(topBar, 1000, 0, null);
    
    //DRAW BACKGROUND AND CASTLE
    g.drawImage(background, 0, MAP_YSTART, screenWidth, screenHeight, null);
    double baseLength = (250.0*(screenHeight/1080.0));
    double baseHeight = (250.0*(screenHeight/1080.0));
    g.drawImage(base, 25*towerSize-15*(screenHeight/1080), (MAP_YSTART+7*towerSize - towerSize/2), 
                (int)baseLength, (int)baseHeight, null);
      
    //LOOP THROUGH TILE MAP AND DRAW TILES/TOWERS ACCORDINGLY 
    //define variable(s) necessary for tilemap traversal
    BufferedImage currTileImg;
    Tile currTile;
    Tower currTower;
    int currX;
    int currY;
    
    //loop through entire tilemap
    for (int row = 0; row < map.size(); row++) { //for each row
      for (int col = 0; col < map.get(0).size(); col++) { //for each column
        currTile = map.get(row).get(col); //get current tile
        currTileImg = currTile.getImage(); //get current tile's image
        currX = currTile.getX(); //get x coordinate of current tile
        currY = currTile.getY(); //get y coordinate of current tile
        currTower = currTile.getTower(); //get tower on current tile (null if nonexistent)
        g.drawImage(currTileImg, currX, currY, towerSize, towerSize, null); //draw the tile
        
        if (currTower != null) { //if there is a tower on the current tile
          g.drawImage(map.get(row).get(col).getTower().getImage(), currX, currY, towerSize, towerSize, null); //draw the tower
          
          if (currTower instanceof GunTower && ((GunTower)currTower).getProjectile() != null) { //if the tower is shooting a rock
            //add rock to list of projectiles to draw
            Projectile p = ((GunTower)currTower).getProjectile(); 
            projectilesToDraw.add(p);      
          } //end of gunTower check
          
          else if (currTower instanceof MagTower) { //if the tower is a magic tower
            double radius = ((MagTower)currTower).getRadius(); //get the tower's radius
            //add a circle to draw
            int[] circleInfo = { (int)((currTower.getX()+towerSize/2)-(radius*1.698)/2), 
              (int)((currTower.getY()+towerSize/2)-(radius*1.698)/2), (int)(radius*1.698)};
            circlesToDraw.add(circleInfo);
          } //end of magTower check
          
          //if the tower is a coin  tower, draw a coin above it
          else if (currTower instanceof CoinTower){
            g.drawImage(allCoins.get(((CoinTower)currTower).getSpriteIdx()), currX+towerSize/2-18, currY, 30, 39, null);
          } //end of coinTower check
        } //end of tower check
      } //end of column loop
    } //END OF TILE MAP DRAWING LOOP
    
    //DRAW MAGIC TOWER CIRCLES
    for (int[] info : circlesToDraw) {
      int alpha = 127; // 50% transparent
      Color myColour = new Color(255, 0, 0, alpha);
      g.setColor(myColour);
      g.drawOval(info[0], info[1], info[2], info[2]);
    } //end of loop through circles
    
    //DRAW THE ENEMIES
    ArrayList<Enemy> loopList = new ArrayList<Enemy>(enemies);
    for (Enemy enemy : loopList) {
      g.drawImage(enemy.getCurrImage(), (int)enemy.getX(), (int)enemy.getY(), towerSize, towerSize+20, null); //draw enemy
      
      //if enemy is set aflame, draw the fire
      if (enemy.isOnFire()) {
        g.drawImage(allFires.get(enemy.getFireIdx()), (int)enemy.getX(), (int)enemy.getY(), towerSize, towerSize+20, null);
      } //end of fire check
      
      //draw health bar
      g.setColor(Color.RED);
      g.fillRect((int)enemy.getX() + towerSize/3, (int)enemy.getY(), ENEMY_HEALTH_BAR_LENGTH, 
          ENEMY_HEALTH_BAR_HEIGHT);
      g.setColor(Color.GREEN);
      double doubleLength = (1.0 * enemy.getHealth() / enemy.getDefHealth()) * ENEMY_HEALTH_BAR_LENGTH;
      int newLength = (int) Math.round(doubleLength);
      g.fillRect((int)enemy.getX() +towerSize/3, (int)enemy.getY(), newLength, ENEMY_HEALTH_BAR_HEIGHT);
    } //end of loop through enemies
    
    //DISPLAY PLAYER STATS
    g.setColor(Color.darkGray);
    g.fillRect(STATS_XPOS, ICON_YPOS, STATS_LENGTH, STATS_HEIGHT);
    g.setColor(Color.CYAN);
    g.drawString("Money: " + player.getMoney(), WINDOW_LENGTH - STATS_LENGTH-40, ICON_YPOS + 15);
    g.drawString("Health: " + player.getHealth(), WINDOW_LENGTH - STATS_LENGTH-40, 
                 ICON_YPOS+STATS_HEIGHT/2 + 3);
    g.drawString("Enemies Killed: " + player.getEnemiesKilled() +"/" + ENEMY_GOAL, 
                 WINDOW_LENGTH - STATS_LENGTH-40, ICON_YPOS+STATS_HEIGHT - 10);
    
    //DRAW ALL ICONS (BUTTONS) 
    for (IconRec ir : allIconRecs) {
      g.setColor(ir.getColor());
      g.fillRect(ir.getX(), ir.getY(), ir.getWidth(), ir.getHeight());
      g.drawImage(ir.getImage(), ir.getX(), ir.getY(), ir.getWidth(), ir.getHeight(), null);
    } //end of loop through icon recs (buttons)
    
    //DRAW TEXT OVER BUTTONS IF HOVERING
    for (IconRec ir : allIconRecs) {
      if (ir.getHovering()) { //if icon is being hovered over
        g.setColor(Color.darkGray);
        g.fillRect(ir.getX(), ir.getY()+ (int)(ir.getHeight()*1.2)-10, (int)(ir.getDesc().length()*5.6), 10);
        g.setColor(Color.CYAN);
        if (ir.getCost() > player.getMoney()) { //if player cannot afford to use button
          g.setColor(Color.RED); //set text color to red
        } //end of afford check
        g.drawString(ir.getDesc(), ir.getX(), ir.getY() + (int)(ir.getHeight()*1.2)); //draw description of button
      } //end of hover check
    } //end of second for loop
    
    //DRAW PROJECTILES
    for (Projectile p : projectilesToDraw) {
      graphics2D.drawImage(p.getImage(), (int)p.getX()-5, (int)p.getY(), 25, 25, null);
    } //end of loop through projectiles
    
    //DRAW ENDING MESSAGES
    if (gameOver) {     
      Font f = new Font("Bernard MT Condensed", Font.BOLD, 50);
      graphics2D.setFont(f);
      if (player.getHealth() < 0) { //if player lost
        graphics2D.setColor(Color.RED);
        graphics2D.drawString("YOU LOST.", (int)(screenWidth/2.5), screenHeight/2);
      } //end of player loss check
      else { //otherwise player won
        graphics2D.setColor(Color.GREEN);
        graphics2D.drawString("YOU WON!", (int)(screenWidth/2.5), screenHeight/2);
      } //end of win check
      f = new Font("Bernard MT Condensed", Font.BOLD, 20);
      graphics2D.setFont(f);
      graphics2D.drawString("Thank you for playing.", (int)(screenWidth/2.5), screenHeight/2+50);
    } //end of ending check
    
    //DRAW INTRO MESSAGE
    if (!started) {
      graphics2D.setColor(Color.RED);
      Font f = new Font("Bernard MT Condensed", Font.BOLD, 50);
      graphics2D.setFont(f);      
      graphics2D.drawString("Welcome to OBSTRUCTION.", (int)(screenWidth/3), screenHeight/2);
      f = new Font("Bernard MT Condensed", Font.BOLD, 20);
      graphics2D.setFont(f);
      graphics2D.drawString("Click anywhere to begin.", (int)(screenWidth/2.5), screenHeight/2+50);
    } //end of game started check
  } // end of paintComponent() -------------------------------------------------------------------------------------------------------
  
  /**
   * genMap()
   * Randomly selects 1 of 5 preset maps and reads it from file
   */
  public static void genMap() throws IOException{
    //define necessary variables
    int mapNum = 1 + (int)(Math.random() * ((5 - 1) + 1));
    String idx = mapNum + "";
    File mapFile = new File("Maps\\" + idx + ".txt");
    Scanner inputFile = new Scanner(mapFile);
    int currY = MAP_YSTART;
    int currX = 0;
    
    //go through file line by line and store information
    while (inputFile.hasNext()) {
      currX = 0;
      ArrayList<Tile> tileLine = new ArrayList<Tile>();
      String line = inputFile.nextLine();
      
      for (int i = 0; i < line.length(); i++) { //for each character in current line
        //create a new tile accordingly
        int tileType = Character.getNumericValue(line.charAt(i));
        Tile tile;
        
        if (tileType == 0) { //if tile is a grass tile, create a grass tile
          tile = new Tile(tileType, normalTiles, currX, currY);
        } //end of grass tile check
        else if(tileType == 1) { //if tile is a path tile, create a path tile
          tile = new Tile(tileType, paths, currX, currY);
        } //end of path tile check
        else {
          tile = new Tile(tileType, obstacles, currX, currY); //if tile is an obstacle tile, create an obstacle tile
        } //end of obstacle tile check
        
        //add the tile to the tile line
        tileLine.add(tile);
        currX += towerSize;
      } //end of character loop through current line
      
      //add the current tile line to the map
      map.add(tileLine);
      currY += towerSize;
    } //end of reading loop
    inputFile.close();
  } //end of genMap() -----------------------------------------------------------------------------------------------------------------
  
  /**
   * main()
   * The main method of the game. Holds the game loop and initializes all necessary values.
   * @param String array of args
   */
  public static void main(String[] args) throws UnsupportedAudioFileException, IOException, InterruptedException{
    playSound(0); //play soundtrack
    
    //LOAD IN ALL IMAGES TO BE USED IN GAME
    skeletons = ImageIO.read(new File("Images\\Enemies\\skeletons.png"));
    mages = ImageIO.read(new File("Images\\Enemies\\mages.png"));
    baldricks = ImageIO.read(new File("Images\\Enemies\\baldricks.png"));
    coins = ImageIO.read(new File("Images\\Other\\coins.png"));
    fires = ImageIO.read(new File("Images\\Other\\fires.png"));
    
    stone = ImageIO.read(new File("Images\\Tiles\\stone.png"));
    stone2 = ImageIO.read(new File("Images\\Tiles\\stone2.png"));
    stone3 = ImageIO.read(new File("Images\\Tiles\\stone3.png"));
    
    grass = ImageIO.read(new File("Images\\Tiles\\grass.png"));
    grass2 = ImageIO.read(new File("Images\\Tiles\\grass2.png"));
    grass3 = ImageIO.read(new File("Images\\Tiles\\grass3.png"));
    
    rock = ImageIO.read(new File("Images\\Tiles\\rock.png"));
    rock2 = ImageIO.read(new File("Images\\Tiles\\rock2.png"));
    
    topBar = ImageIO.read(new File("Images\\Other\\topBar.png"));
    hammer = ImageIO.read(new File("Images\\Other\\hammer2.png"));
    fastforward = ImageIO.read(new File("Images\\Other\\fastforward.png"));
    pause = ImageIO.read(new File("Images\\Other\\pause.png"));
    coin = ImageIO.read(new File("Images\\Other\\coin.png"));
    skull = ImageIO.read(new File("Images\\Other\\skull.png"));
    heal = ImageIO.read(new File("Images\\Other\\heal.png"));
    
    rockProjectile = ImageIO.read(new File("Images\\Other\\rock.png"));
    background = ImageIO.read(new File("Images\\Other\\background.jpg"));
    base = ImageIO.read(new File("Images\\Other\\base.png"));
    
    gunTower1 = ImageIO.read(new File("Images\\Towers\\gunTower1.png"));
    gunTower2 = ImageIO.read(new File("Images\\Towers\\gunTower2.png"));
    gunTower3 = ImageIO.read(new File("Images\\Towers\\gunTower3.png"));
    gunTowers.add(gunTower1);
    gunTowers.add(gunTower2);
    gunTowers.add(gunTower3);
    
    coinTower1 = ImageIO.read(new File("Images\\Towers\\coinTower1.png"));
    coinTower2 = ImageIO.read(new File("Images\\Towers\\coinTower2.png"));
    coinTower3 = ImageIO.read(new File("Images\\Towers\\coinTower3.png"));
    coinTowers.add(coinTower1);
    coinTowers.add(coinTower2);
    coinTowers.add(coinTower3);
    
    magTower1 = ImageIO.read(new File("Images\\Towers\\magTower1.png"));
    magTower2 = ImageIO.read(new File("Images\\Towers\\magTower2.png"));
    magTower3 = ImageIO.read(new File("Images\\Towers\\magTower3.png"));
    magTowers.add(magTower1);
    magTowers.add(magTower2);
    magTowers.add(magTower3);
    
    //STORE AND SEPARATE COIN IMAGES
    int currX = 0;
    int currY = 0;
    for (int i = 0; i < 6; i++) { //loop to separate coin sprites
      BufferedImage currImage = coins.getSubimage(currX, currY, 700/6, 200);
      allCoins.add(currImage);
      currX += 700/6;
    } //end of loop through coin sprites
    
    //STORE AND SEPARATE FIRE IMAGES
    currX = 0;
    currY = 0;
    for(int row =0; row < 4; row++) { //loop to separate fire sprites
      for(int col = 0; col < 8; col++) {
        BufferedImage currImage = fires.getSubimage(currX, currY, 64, 128);
        allFires.add(currImage);
        currX += 64;
      } //end of column loop
      currX = 0;
      currY += 128;
    } //end of row loop
    
    //STORE TILE IMAGES
    paths.add(stone);
    paths.add(stone2);
    paths.add(stone3);
    obstacles.add(rock);
    obstacles.add(rock2);   
    normalTiles.add(grass);
    normalTiles.add(grass2);
    normalTiles.add(grass3);
    
    //ORGANIZE ENEMY IMAGE STORING
    allSkeletons.add(skeletonsUp);
    allSkeletons.add(skeletonsLeft);
    allSkeletons.add(skeletonsDown);
    allSkeletons.add(skeletonsRight);    
    allMages.add(magesUp);
    allMages.add(magesLeft);
    allMages.add(magesDown);
    allMages.add(magesRight);   
    allBaldricks.add(baldricksUp);
    allBaldricks.add(baldricksLeft);
    allBaldricks.add(baldricksDown);
    allBaldricks.add(baldricksRight);
    
    //SEPARATE AND STORE ENEMY IMAGES
    currX = 0;
    currY = 0;    
    for (int r = 0; r < 4; r++) { //loop to separate enemy sprites
      for (int i = 0; i < 9; i++) {
        BufferedImage currImage = skeletons.getSubimage(currX, currY, 64, 64);
        allSkeletons.get(r).add(currImage);
        
        currImage = mages.getSubimage(currX, currY, 64, 64);
        allMages.get(r).add(currImage);
        
        currImage = baldricks.getSubimage(currX, currY, 64, 64);
        allBaldricks.get(r).add(currImage);     
        currX += 64;
      } //end of column loop
      currX = 0;
      currY += 64;
    } //end of row loop
    
    //CREATE MISC ICON RECS (BUTTONS)
    upgradeIcon = new IconRec(ICON_SIZE+20, ICON_SIZE+20, STATS_XPOS - ICON_SIZE - 35, ICON_YPOS, 
                              "Click and then select tower to upgrade it.", 0, hammer); //create tower upgrade button
    coinIcon = new IconRec(ICON_SIZE+20, ICON_SIZE+20, STATS_XPOS - 2*ICON_SIZE - 70, ICON_YPOS, 
                           "Click and then select tower to sell it.", 0, coin); //create sell tower button
    fastForwardIcon = new IconRec(ICON_SIZE/2, ICON_SIZE/2, STATS_XPOS + STATS_LENGTH + 10, ICON_YPOS+5, 
                                  "Fast-forward", 0, fastforward); //create fast forward button
    pauseIcon = new IconRec(ICON_SIZE/2, ICON_SIZE/2, STATS_XPOS + STATS_LENGTH + 10, 
                            ICON_YPOS+STATS_HEIGHT-ICON_SIZE/2-5, "Pause game", 0, pause); //create pause button
    pauseIcon.setClicked(true); //set pause button to clicked for beginning of the game
    
    //add the new buttons
    allIconRecs.add(upgradeIcon);
    allIconRecs.add(coinIcon);
    allIconRecs.add(fastForwardIcon);
    allIconRecs.add(pauseIcon);
    
    //DEFINE TOWER ICON DESCRIPTIONS AND IMAGES
    String gunTowerDesc = "Fires arrows at nearby enemies. Cost: " + GUN_TOWER_COST;
    String coinTowerDesc = "Generates coins at regular intervals. Cost: " + COIN_TOWER_COST;
    String magTowerDesc = "Hits enemies within certain radius with fireballs. Cost: " + MAG_TOWER_COST;
    
    String[] descs= new String[] {gunTowerDesc, coinTowerDesc, magTowerDesc};
    int[] costs = {GUN_TOWER_COST, COIN_TOWER_COST, MAG_TOWER_COST};
    ArrayList<BufferedImage> towerImages = new ArrayList<BufferedImage>();
    towerImages.add(gunTower1);
    towerImages.add(coinTower1);
    towerImages.add(magTower1);
    
    //CREATE TOWER ICONS FOR GUI
    towerIconRecs = new ArrayList<IconRec>();
    currX = 20;
    for (int i = 0; i < 3; i++) { //loop for each tower icon
      IconRec ir = new IconRec(ICON_SIZE+20, ICON_SIZE+20, currX, ICON_YPOS, descs[i], costs[i], towerImages.get(i));
      towerIconRecs.add(ir);
      allIconRecs.add(ir);
      currX += 100;
    } //end of tower icon creation loop
    
    //CREATE SPECIAL ABILITY ICONS
    healIcon = new IconRec(ICON_SIZE+20, ICON_SIZE+20, currX + 20, ICON_YPOS, "Heal yourself", 250, heal);
    skullIcon = new IconRec(ICON_SIZE+20, ICON_SIZE+20, currX + 2*ICON_SIZE+10, ICON_YPOS, "Kill all enemies", 500, skull);
    allIconRecs.add(skullIcon);
    allIconRecs.add(healIcon);
    
    //SET VARIABLES AND GENERATE MAP FOR THE GAME
    //get screen dimensions
    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
    screenWidth = (int)(screenSize.getWidth());
    screenHeight = (int)(screenSize.getHeight());
    
    towerSize = (int)((screenHeight - MAP_YSTART) / 14.5); //calculate tower size based on screen dimensions
    gunRange = 150.0* (screenWidth/1366.0); //calculate gun tower range based on screen dimensions
    magRadius = 100.0* (screenWidth/1366.0); //calculate magic tower radius based on screen dimensions
    genMap(); //generate the map
    
    //CREATE GAME AND JFRAME
    MainGame mg = new MainGame();
    mg.addMouseListener(mg);
    mg.addMouseMotionListener(mg);
    mg.setBackground(Color.CYAN);
    
    JFrame jf = new JFrame();
    jf.setTitle("Obstruction -- A 2D Tower Defense Game");
    jf.setSize(screenWidth, screenHeight); 
    
    jf.add(mg);
    jf.setVisible(true);
    jf.setResizable(false);
    jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); 
        
    //CREATE PLAYER
    player = new Player(PLAYER_HEALTH, PLAYER_MONEY);
        
    //MAIN GAME LOOP
    while (!gameOver) { //while the game hasn't been lost
      long origTime = System.currentTimeMillis(); //get initial time
      while (!gameOver) { //while the game hasn't been lost   
          long currTime = System.currentTimeMillis(); //get the current time
          if (currTime-origTime >= gameLoopDelay) { //if certain amount of time has passed
            while(currTime-origTime >= gameLoopDelay){ //while difference between curr time and initial time greater than delay
              //update game state here
              if (!pauseIcon.isClicked())  //if game isn't paused
                mg.updateWorld(); //update the world
                origTime += gameLoopDelay; //update initial time              
              mg.repaint(); //repaint the world
            } //end of inner while loop
          } //end of time difference check
      } //end of game over check
    } //end of main game loop
    mg.repaint(); //repaint the game one more time for the ending message
    TimeUnit.SECONDS.sleep(7);
    System.exit(0);
  } //end of main() ---------------------------------------------------------------------------------------------------------------------

  /**
   * updateWorld()
   * Holds essential game logic and keeps everything up to date
   */
  public void updateWorld() {    
    //REMOVE SOUNDS THAT ARE DONE PLAYING
    ArrayList<Clip> soundList = new ArrayList<Clip>(currSounds);
    for (Clip sound : soundList) { //for each current sound
      if (!sound.isRunning()) { //if this sound is running
        currSounds.remove(sound); //remove the sound
      } //end of sound running check
    } //end of loop through current sounds
    
    //CHECK FOR ENDGAME
    if (player.getHealth() <= 0 || player.getEnemiesKilled() >= ENEMY_GOAL) { //if player has either won or lost
      gameOver = true; //set game over to true
    } //end of game ending check
    
    //MANAGE FAST FORWARD BUTTON
    if (fastForwardIcon.isClicked()) { //if it is clicked
      gameLoopDelay = GAME_LOOP_DELAY - fastForwardSpeed; //update gameloop delay accordingly
    } //end of click check
    else { //otherwise not clicked
      gameLoopDelay = GAME_LOOP_DELAY; //reset gameloopDelay
    } //end of not clicked check
    
    //MANAGE ENEMY SPAWNING
    enemyFreqCount += enemyFreq; //increment enemy frequency counter
    if (enemyFreqCount > 10000) { //if it is time for an enemy to spawn
      int enemyType =(int)(Math.random() * 6); //random between 0 and 5 inclusive
      double speed = enemyMinSpeed + (int)(Math.random() * ((enemyMaxSpeed - enemyMinSpeed) + 1)); //set speed
      double health = enemyMinHealth + (int)(Math.random() * ((enemyMaxHealth - enemyMinHealth) + 1)); //set health
     
      //create an enemy
      Enemy enemy;
      if (enemyType < 3) { //if enemy is a skeleton
        enemy = new Enemy(health, speed, 1, 0, 80+(6*towerSize), 6, 0, allSkeletons);
      } //end of skeleton check
      else if (enemyType < 5) { //if enemy is a baldrick
        enemy = new Enemy(health*1.5, speed*0.8, 1, 0, 80+(6*towerSize), 6, 0, allBaldricks);
      } //end of baldrick check
      else { //otherwise enemy is a mage
        enemy = new Enemy(health*2.5, speed*0.6, 1, 0, 80+(6*towerSize), 6, 0, allMages);
      } //end of mage check
      
      enemies.add(enemy); //add new enemy
      enemyFreqCount = 0; //reset enemy frequency count
    } //end of enemy spawn time check
    
    //MANAGE AND UPDATE CURRENT ENEMIES
    ArrayList<Enemy> loopList = new ArrayList<Enemy>(enemies);
    for (Enemy enemy : loopList) { //loop through all current enemies    
      //Deal with Magic Towers
      if (enemy.getNearbyMagTowers().size()  > 0) { //if within a magic tower radius
        if (!enemy.isOnFire()) { //if enemy is not yet on fire
          playSound(1); //play fire sound
        } //end of fire check
        enemy.setFireState(true); //set enemy on fire
      } //end of magic tower radius check
      else { //otherwise not within magic tower radius
        enemy.setFireState(false); //ensure that enemy is not lit aflame
      } //end of not within magic radius check
      
      //Check for leaving map
      if (enemy.getX() > 24.5*towerSize) { //if enemy has left map
        player.setHealth(player.getHealth()-(int)(enemy.getHealth())); //reduce player's health
        enemies.remove(enemy); //remove the enemy
        playSound(2); //play corresponding sound
      } //end of map leaving check
      
      //Check for dead enemies
      if (enemy.getHealth() <= 0) { //if enemy is dead
        enemies.remove(enemy); //remove the enemy
        playSound(3); //play death sound
        enemyMinHealth += player.getEnemiesKilled();
        enemyMaxHealth += player.getEnemiesKilled();
        player.setMoney((int)(player.getMoney() + (enemy.getDefHealth() * enemy.getSpeed() * 0.1))); //give player money
        player.setEnemiesKilled(player.getEnemiesKilled()+1); //increment kill counter
      } //end of dead enemy check
      
      //Update Enemy Sprite  to add Animation
      enemy.setMoveCount(enemy.getMoveCount()+1); //update enemy's move counter
      enemy.setSpriteCount(enemy.getSpriteCount()+1); //update enemy's sprite counter    
      double tempSpeed = 1.0 / enemy.getSpeed(); //calculate sprite speed
      if ((enemy.getSpriteCount() / tempSpeed) >= 5) { //if it is time to update the sprite
        //update the enemy's sprite index and counter
        enemy.updateSpriteIdx();
        enemy.setSpriteCount(0);
      } //end of sprite update check
      
      //Update Enemy Fire Sprite to add Animation
      enemy.setFireCount(enemy.getFireCount()+1); //increment fire count
      tempSpeed = 1.0 / FIRE_BURN_FREQ; //calculate sprite speed
      if ((enemy.getFireCount() / tempSpeed) >= 5) { //if it is time to update the sprite
        //update the enemy's fire sprite index and counter
        enemy.updateFireIdx();
        enemy.setFireCount(0);
      } //end of if check
      
      //Change Enemy Direction if Necessary
      double countLimit = (towerSize / enemy.getSpeed()); //set move count limit
      if (enemy.getMoveCount() >= countLimit) { //if enemy is in centre of tile       
        if(Math.abs(enemy.getDirection()) == 1) { //if enemy is moving left or right
          enemy.setCol(enemy.getCol() + enemy.getDirection()); //set the current column accordingly
        } //end of left and right check
        else if (Math.abs(enemy.getDirection()) == 2) { //if enemy is moving up or down
          enemy.setRow(enemy.getRow() - (enemy.getDirection()/2)); //set the current row accordingly
        } //end of up and down check
        
        int enemyRow = enemy.getRow(); //get enemy row
        int enemyCol = enemy.getCol(); //get enemy column
        
        //Do direction checks if not out of bounds
        if (enemyCol >= 0 && enemyCol < map.get(0).size() && enemyRow >= 0 && enemyRow < map.size()) {      
          //if there is a path tile to the right and enemy isn't moving left, make the enemy go right
          if(enemyCol < map.get(0).size()-1 && map.get(enemyRow).get(enemyCol+1).getType() == 1 
               && enemy.getDirection() != -1) {
            enemy.setDirection(1);
          } //end of go right check
          
          //if there is a path tile to the left and enemy isn't moving right,  make the enemy go left
          else if (enemyCol > 0 && map.get(enemyRow).get(enemyCol-1).getType() == 1 
                     && enemy.getDirection() != 1) {
            enemy.setDirection(-1);
          } //end of go left check
          
          // if there is a path tile up and enemy isn't moving down, make the enemy go up
          else if(enemyRow > 0 && map.get(enemyRow-1).get(enemyCol).getType() == 1 && enemy.getDirection() != -2) {
            enemy.setDirection(2);
          } //end of go up check
          
          //if there is a path tile down and enemy isn't moving up, make the enemy go down
          else if (enemyRow < map.size()-1 && map.get(enemyRow+1).get(enemyCol).getType() == 1 
                     && enemy.getDirection() != 2) {
            enemy.setDirection(-2);
          } //end of go down check
        } //end of out of bounds check
        enemy.setMoveCount(0); //reset enemy move count      
      } //end of centred in tile check
      enemy.move(); //move the enemy
    } //end of loop through enemies
    
    //KEEP TOWERS AND THEIR FUNCTIONALITY UP TO DATE   
    for (int row = 0; row < map.size(); row++) { //for each row
      for (int col = 0; col < map.get(0).size(); col++) { //for each column
        Tile currTile = map.get(row).get(col); //get current tile
        Tower currTower = currTile.getTower(); //get tower on current tile
        
        //If the Tower is a Coin Tower, Update the Coin Sprite accordingly
        if (currTower instanceof CoinTower) {
          ((CoinTower)currTower).setSpriteCount(((CoinTower)currTower).getSpriteCount()+1); //increment the sprite count
          double tempFreq = 1.0 / COIN_SPIN_FREQ; //calculate the sprite speed
          if ((((CoinTower)currTower).getSpriteCount() / tempFreq) >= 200) { //if it is time to update the sprite
            //update the sprite index and counter
            ((CoinTower)currTower).updateSpriteIdx();
            ((CoinTower)currTower).setSpriteCount(0);
          } //end of sprite  update check
        } //end of coinTower check
        
        //If the tower is a gun tower that is currently shooting, update projectile
        if (currTower instanceof GunTower && ((GunTower)currTower).getProjectile() != null) {
          Projectile p = ((GunTower)currTower).getProjectile(); //get the projectile
          for (Enemy enemy : enemies) { //loop through enemies
            //if projectile has reached enemy, deduct health from enemy and reset projectile
            if (p.getX() > enemy.getX() && p.getX() < enemy.getX()+towerSize && p.getY() > enemy.getY() 
                  && p.getY() < enemy.getY()+towerSize && ((GunTower)currTower).getProjectile() != null) {
              enemy.setHealth(enemy.getHealth() - ((GunTower)currTower).getDamage());
              ((GunTower)currTower).resetProjectile();
            } //end of enemy hit check
          } //end of loop through enemies
          p.update(); //update projectile state
        } //end of guntower and projectile check
        
        if (currTower != null) { //if there is a tower on the current tile
          currTower.setFreqCount(currTower.getFreqCount()+currTower.getFreq()); //increment tower frequency counter
          if (currTower.getFreqCount() > 10000) { //if it is time to use the tower
            currTower.use(enemies, player); //use the tower
            //if the tower is a gun tower and has just fired a projectile, play a firing sound
            if (currTower instanceof GunTower && ((GunTower)currTower).getProjectile() != null) { 
              playSound(4);
            } //end of gun tower check
            //if the tower is a coin tower and just earned money, play a money sound
            else if (currTower instanceof CoinTower) {
              playSound(5);
            } //end of coin tower check
            currTower.setFreqCount(0); //reset tower frequency
          } //end of if check
        } //end of currTower null check
      } //end of column loop
    } //end of row loop
  } //end of updateWorld() ------------------------------------------------------------------------------------------------------------
  
  /**
   * mouseMoved()
   * Checks for mouse motion and updates world accordingly
   * @param The mouse event
   */
  @Override 
  public void mouseMoved(MouseEvent e) {
    int mouseX = e.getX();
    int mouseY = e.getY();
    //Check for button hover
    for (IconRec ir : allIconRecs) { //loop through buttons
      //if button is being hovered over, update its hover state
      if ( (mouseX >= ir.getX() && mouseX <= ir.getX() + ir.getWidth()) && (mouseY >= ir.getY()
          && mouseY <= ir.getY() + ir.getHeight()) ) {
        ir.setHovering(true);
      } //end of hover check      
      else { //if not being hovered over
        ir.setHovering(false);
      } //end of no hover check
    } //end of loop through buttons
  } //end of mouseMoved()
  
  /**
   * mousePressed()
   * Checks for mouse press and updates world accordingly
   * @param The mouse event
   */
  @Override
  public void mousePressed(MouseEvent e) {
    //initialize necessary variables
    int mouseX = e.getX();
    int mouseY = e.getY();
    boolean clicked = false;
    int minX;
    int maxX;
    int minY;
    int maxY;
    
    //CHECK FOR BUTTON CLICKS
    for (IconRec iconRec : allIconRecs) { //loop through icon recs (buttons)
      minX = iconRec.getX();
      maxX =iconRec.getX() + iconRec.getWidth();
      minY = iconRec.getY();
      maxY = iconRec.getY() + iconRec.getHeight();
      if (mouseX >minX && mouseX < maxX && mouseY > minY && mouseY < maxY) { // if an icon has been clicked on
        //update icon state accordingly
        if (iconRec.isClicked()) {
          iconRec.setClicked(false);
        } //end of already clicked check       
        else {         
          for (IconRec ir : allIconRecs) { //loop through all buttons and set them to un-clicked
            ir.setClicked(false);            
          } //end of inner loop through icons
          iconRec.setClicked(true);
          clicked = true;
        } //end of else statement
      } //end of icon click check 
    } //end of loop through icons
    
    if (pauseIcon.isClicked()) {
      updateWorld();
    } //end of pause click check
    
    //CHECK FOR TILE CLICKS
    for (int row = 0; row < map.size(); row++) { //for each row in tilemap
      for (int col = 0; col < map.get(0).size(); col++) { //for each column in tilemap
        Tile currTile = map.get(row).get(col);
        minX = currTile.getX();
        maxX = currTile.getX() + towerSize;
        minY = currTile.getY();
        maxY = currTile.getY() + towerSize;
        
        if (mouseX > minX && mouseX < maxX && mouseY > minY && mouseY < maxY) { //if user clicked on this tile
          //HEAL ABILITY CHECK
          if (healIcon.isClicked()) { //if heal ability is already clicked
            //update button state
            healIcon.setClicked(false);
            clicked = true;
            //if player can afford to use it, use the ability, deduct money and play the sound.
            if (player.getMoney() >= healIcon.getCost() && player.getHealth() != PLAYER_HEALTH) {
              playSound(6);
              player.setMoney(player.getMoney() - healIcon.getCost());
              player.setHealth(PLAYER_HEALTH);
            } //end of afford check
          } //end of heal ability check
          
          //SKULL ABILITY CHECK
          if (skullIcon.isClicked()) { //if skull ability is already clicked
            //update button state
            skullIcon.setClicked(false);
            clicked = true;
            //if player can afford to use it, use the ability and deduct money
            if (player.getMoney() >= skullIcon.getCost() && enemies.size() > 0) {
              player.setMoney(player.getMoney() - skullIcon.getCost());
              for (Enemy enemy : enemies) { //loop through all enemies
                enemy.setHealth(0); //kill the enemy
              } //end of loop through enemies
            } //end of afford check
          } //end of skull ability check
          
          //TOWER PLACEMENT CHECK
          if (currTile.getType() == 0 && currTile.getTower() == null) { //if a tower can be placed
            Tower currTower;
            for (int i = 0; i < towerIconRecs.size(); i++) { //loop through tower icons
              if (towerIconRecs.get(i).isClicked()) {
                if (i == 0) { //if gun tower selected, create a gun tower
                  currTower = new GunTower(GUN_TOWER_COST, GUN_TOWER_FREQ, currTile.getX(), currTile.getY(), 
                                           towerSize, gunTowers, rockProjectile, gunRange, GUN_DAMAGE, WINDOW_HEIGHT);
                } //end of gun tower check
                
                else if (i == 1) { //if coin tower selected, create a coin tower
                  currTower = new CoinTower(COIN_TOWER_COST, COIN_TOWER_FREQ, currTile.getX(), currTile.getY(), 
                                            towerSize, coinTowers, COIN_AMOUNT);
                } //end of coin tower check
                
                else { //if magic tower selected, create a magic tower
                  currTower = new MagTower(MAG_TOWER_COST, MAG_TOWER_FREQ, currTile.getX(), currTile.getY(), 
                                           towerSize, magTowers, magRadius, MAG_DAMAGE);
                } //end of magic tower check
                towerIconRecs.get(i).setClicked(false); //deselect appropriate tower button
                if (player.getMoney() >= currTower.getCost()) { //if player can afford tower
                  //place down tower
                  player.setMoney(player.getMoney() - currTower.getCost());
                  currTile.addTower(currTower);
                } //end of afford check
              } //end of towerClicked iconRec check
            } //end of loop through tower icons
          } //end of tile validity check
          
          else if (currTile.getType() == 0 && currTile.getTower() != null) { //if tile is occupied by a tower
            //UPGRADE ICON CHECK
            if (upgradeIcon.isClicked()) { //if the upgrade tower button is already clicked
              //get the current tower and update its stats and look accordingly
              Tower currTower = currTile.getTower();
              if (currTower.getUpgradeIdx() < 2 && currTower.getUCosts()[currTower.getUpgradeIdx()] < player.getMoney()) {
                player.setMoney(player.getMoney() - currTower.getUCosts()[currTower.getUpgradeIdx()]);
                currTower.upgrade();
                upgradeIcon.setClicked(false);
                playSound(7);
              } //end of upgrade limit and afford check
            } //end of upgrade icon click check 
            
            //SELL ICON CHECK
            else if (coinIcon.isClicked()) { //if the sell tower button is already clicked
              //get the current tower and give the player money accordingly
              Tower currTower = currTile.getTower();
              player.setMoney(player.getMoney() + (int)(0.5*(currTower.getCost() + (5*currTower.getUpgradeIdx()))));
              //if the current tower is a magic tower, clear the fire from nearby enemies and stop playing the fire sound.
              if (currTower instanceof MagTower) {
                ((MagTower)currTower).clearNearbyEnemies();
                fireClip.stop();
              } //end of magic tower check
              currTile.removeTower();
              playSound(8);
              coinIcon.setClicked(false);
            } //end of coin tower clicked check
          } //end of else statement
        } //end of tile click check 
      } //end of column loop
    } //end of row loop
    
    //deselect all buttons if necessary
    if (!clicked) {
      for (IconRec ir : allIconRecs) { //loop through all buttons
        ir.setClicked(false); //deselect button
      } //end of loop through buttons    
    } //end of unclicking everything
    started = true; //something has been clicked, so the game must begin.
  } //end of mousePressed() ----------------------------------------------------------------------------------------------------------
  
  /**
   * playSound()
   * Loads and plays the specified sound
   * @param Index of sound to be played
   */
  public static void playSound(int idx) {
    try {
      if (currSounds.size() <= 20) { //if less than 20 sounds currently playing
        //create new sound according to index provided
        File audioFile = new File("Sound\\" + soundNames[idx] + ".wav");
        AudioInputStream audioStream = AudioSystem.getAudioInputStream(audioFile);
        DataLine.Info info = new DataLine.Info(Clip.class, audioStream.getFormat());
        Clip clip = (Clip) AudioSystem.getLine(info);
        currSounds.add(clip);
        
        if (soundNames[idx].equals("fireSound")) { //if fire sound is to be played
          if (fireClip == null || !fireClip.isRunning()) { //if no fire sound playing at the moment,
            //start a new fire sound
            fireClip = clip;
            fireClip.setFramePosition(0);
          } //end of no running fire sound check
          else { //otherwise
            return; //return, and do not create a new firesound
          } //end of existing fire sound check
        } //end of fire sound check
        //start clip
        clip.addLineListener(new MyLineListener());
        clip.open(audioStream);
        clip.start();
        numSounds++;
      } //end of numSounds check
    }catch (Exception e) {
      e.printStackTrace();
       } //end of catch
} //end of playSound()
  
  //MouseListener Methods to override but not implement
  
  /**
   * mouseDragged()
   * Checks for mouse drag
   * @param The mouse event
   */
  @Override 
  public void mouseDragged(MouseEvent e) {}
  
  /**
   * mouseClicked()
   * Checks for mouse click
   * @param The mouse event
   */
  @Override
  public void mouseClicked(MouseEvent e) {}
  
  /**
   * mouseReleased()
   * Checks for mouse release
   * @param The mouse event
   */
  @Override
  public void mouseReleased(MouseEvent e) {}

  /**
   * mouseEntered()
   * Checks for mouse enter
   * @param The mouse event
   */
  @Override
  public void mouseEntered(MouseEvent e) {}
  
  /**
   * mouseExited()
   * Checks for mouse exit
   * @param The mouse event
   */
  @Override
   public void mouseExited(MouseEvent e) {}   
} //end of MainGame class
